# 详细设计

> 详细设计为每个模块完成的功能进行具体描述，要把功能描述转变为精确的、 结构化的过程描述，并使用流程图和伪代码等方式描述各功能模块。

## 一、全局变量和数据结构设计

### 1.1 全局变量

本程序中定义的全局变量有多个，包含程序执行过程中所需的各种步骤。

#### 关系表

关系表为后端程序中对关系进行持久化的数据结构。当涉及到关系的新增/删除，以及表达式的运算时，均需要与该表进行交互，进行关系的读与写。

该变量定义与接口实现类`RelationServiceImpl`下。呈现形式为Hash表形式，其中Key为关系名，字符串类型，Value为关系数据结构，RelationBo类型。

```java
private static final ConcurrentHashMap<String, RelationBo> relations;
```

#### 关系运算工具类

运算工具类`ComputingUtil`用于计算关系运算符的结果。其包含了8个对外暴露的方法，分别对应着不同的8种运算符。

```java
public class ComputingUtil {

    public static RelationBo and(RelationBo r1, RelationBo r2);

    public static RelationBo or(RelationBo r1, RelationBo r2);

    public static RelationBo diff(RelationBo r1, RelationBo r2);

    public static RelationBo prod(RelationBo r1, RelationBo r2);

    public static RelationBo div(RelationBo r1, RelationBo r2);

    public static RelationBo select(RelationBo r, String condition);

    public static RelationBo project(RelationBo r, int[] cols);

    public static RelationBo join(RelationBo r1, RelationBo r2);
}
```

#### 常量工具类

涉及到的常量主要定义为各运算符在表达式中的表示，符号表达的规则如下。通过`#`号开头以区分当前字符串为关系名还是运算符。

| 运算符 | 含义   | 字符串中的表示  | 举例                         | 说明  |
| --- | ---- | -------- | -------------------------- | --- |
| ∪   | 并    | #or      | A #or B                    |     |
| ∩   | 交    | #and     | A #and B                   |     |
| −   | 差    | #diff    | A #diff B                  |     |
| ×   | 笛卡尔积 | #prod    | A #prod B                  |     |
| σ   | 选择   | #select  | #select(A,name=\\"Jack\\") |     |
| π   | 投影   | #project | #project(A,name)           |     |
| ⋈   | 连接   | #join    | #join(A,B,0~3)             |     |
| ÷   | 除    | #div     | A #div B                   |     |

常量工具类`Constant`对上述运算符进行记录，以及记录一些其它会用到的常量，如运算符优先级等。

### 1.2 数据结构

#### **后端**

##### 关系

后端存储关系主要设计两个类，`RelationVo`以及`RelationBo`，前者主要用于与前端交互时存储从前端送来的关系/准备送至前端的关系信息，后者则主要用于后端业务处理，包括关系的存储/表达式的运算等。

鉴于二者相似性，仅详细介绍`RelationBo`的成员，伪代码如下。

```java
RelationBo {

    // 关系行长
    int rowLen;

    // 关系列长
    int colLen;

    // 关系列名
    String[] colName;

    // 关系内容，通过二维数组存储
    String[][] content;

    // bo与vo相互转换的方法
    toRelationVo(RelationBo bo, String name);

    toRelationBo(RelationVo vo, String name);
}
```

##### 常量类

此外，常量类`Constant`，用于统一管理后端程序中用到的常量。

```java
public class Constant {

    String OR = "#or";

    String AND = "#and";

    ...
}
```

#### **前后端交互**

前后端交互主要用到两个数据结构。

##### relation 表示关系的数据结构（表）

包含五个字段：关系名、行长、列长、列名以及表的内容。

表的内容（content）使用一个字符串表示，每个元素间使用英文逗号分隔，应当满足字符串内元素的数量等于行长乘以列长。

举例，以下关系以及对应的Json结构：

| name   | age | gender |
| ------ | --- | ------ |
| Johnny | 18  | male   |
| Jack   | 20  | male   |

```json
{
    "relation_name":"student",
    "row_len":3,
    "col_len":2,
    "col_name":"name,age,gender",
    "content":"Johnny,18,male,Jack,20,male"
}
```

##### response 响应

前端调用接口后返回的是一个response对象，包含三个字段：状态码、信息、数据体。如果是需要返回结果的请求调用，结果对象会存储在数据体中。

举例，一个请求成功，且返回数据存放在data中的response对象：

```json
{
    "code":200,
    "msg":"ok",
    "data":{
        "relation_name":"student",
        "row_len":3,
        "col_len":2,
        "col_name":"name,age,gender",
        "content":"Johnny,18,male,Jack,20,male"
    }
}
```

#### **前端**

前端主要涉及两个数据结构，分别用于存储关系表及运算结果表。

##### 关系表

关系表用于存储用户输入的关系名，行数，列数，列名，关系表内容，便于后续发送至后端。同时使用dis标识该表的提交状态，避免多次提交同一关系表。

```javascript
domains: [{
        name: '',
        row: '',
        col: '',
        col_name: '',
        text: '',
        dis: false
      }]
```

##### 运算结果表

运算结果表中，每行用id标识行号，id依次递加。行中每项值使用num和data两个变量标识，其中num为列名，data为该项值。

```javascript
list: [{
        id: '',
        dataList: [{
          num: '',
          data: ''
        }]
```

## 二、各个功能模块设计

> 主要包括以下元素： A. 功能描述 B. 输入数据（用户输入的数据及这些数据的有效性检测） C. 输出数据（描述该功能产生的数据以及这些数据德表现形式） D. 算法和流程（根据输入数据产生输出的算法流程图） E. 数据设计（改功能模块局部数据结构说明，数据结构名称、用途 以及数据库表等） F. 源程序文件说明（该功能模块的源程序文件以及功能说明） G. 主要函数说明（包括函数名称、功能、格式、参数等说明）

程序结构的各模块关系以及数据流关系如图所示。以下为每个模块单独进行详细的介绍。

<img src=".\assets\模块之间的层次结构以及模块间的调用关系.drawio.png" alt="image-20221105235133897" style="zoom:50%;" />

### 2.1 用户交互模块

#### 功能描述

从属于前端模块，负责向用户提供基本的交互界面，负责提供整个应用程序的对外用户接口。用户通过该模块可以执行关系的新增/删除以及表达式计算等操作，该模块也负责将计算结果为用户呈现。

#### 输入数据

对于用户端而言，用户通过该模块将关系的信息（如关系名、行长、列长、内容等）输入系统；对于数据通信模块，数据通信模块将响应（包含请求结果、状态码等）交由用户交互模块处理。

输入数据格式是否符合规范要求不在本层做检验。

#### 输出数据

该模块负责将用户的输入数据按特定格式处理，交由数据通信模块；同时，处理数据通信模块传来的响应数据报，给用户输出、展现对应的系统处理结果。

![image-20221122155219604](.\assets\image-20221122155219604.png)

#### 算法和流程

该模块不涉及特定算法。

#### 数据设计

前端主要涉及两个数据结构，分别用于存储关系表及运算结果表。

关系表用于存储用户输入的关系名，行数，列数，列名，关系表内容，便于后续发送至后端。同时使用dis标识该表的提交状态，避免多次提交同一关系表。

运算结果表中，每行用id标识行号，id依次递加。行中每项值使用num和data两个变量标识，其中num为列名，data为该项值。

#### 源程序文件说明

@薛晴 此部分后续完成及修改后贴代码

该模块主要包含三个部分，分别是关系管理部分、表达式输入部分和结果呈现部分。

##### 关系管理部分

用户可以在此对关系进行增删以及提交重置，定义所需的关系表。

##### 表达式输入部分

用户可在此输入关系表达式，其中关系名使用用户在前一部分自定义的名称，关系运算符使用按钮填入表达式。

##### 结果呈现部分

用户提交关系式成功后在此处获取结果表。

#### 主要函数说明

该模块主要包括关系管理部分中的addDomain函数和表达式输入部分中的handleInputBlur、labClick函数。

```javascript
// 新增表单项
    addDomain () {
      this.domains.push({
        name: '',
        row: '',
        col: '',
        col_name: '',
        text: '',
        dis: false,
        key: Date.now()// 获取当前时间作为key，以确保表单的唯一key值
      })
    }
//  获取光标位置
    handleInputBlur (e) {
      this.cursorIndex = e.srcElement.selectionStart
    }
// 点击标签按钮，处理文本框文本内容
    labClick (lab) {
      let s1 = ''
      let s2 = ''
      if (this.expression.length < this.cursorIndex) {
        this.expression = this.expression + lab
      } else {
        s1 = this.expression.toString()
        s2 = this.expression.toString()
        this.expression = s1.substring(0, this.cursorIndex) +
          lab +
          s2.substring(this.cursorIndex, this.expression.length)
      }
      this.$refs.inputArea.focus()
    }
```

### 2.2 数据通信模块

#### 功能描述

负责前后端程序的通信，实现上采用了http接口的形式。

#### 输入数据

对于前端，输入数据为用户定义的关系、用户执行的关系操作、表达式以及计算表达式操作等；对于后端，输入数据为关系业务模块以及表达式计算模块两个模块所返回的处理结果。

本层会对不合规的输入数据做初步检验，包含列长列名长度一致检查、元素非空检查等。

#### 输出数据

用户输入的数据会按预先规定的格式包装成http数据报，输出交由后端模块进行处理；后端处理后的数据会交由该模块，进行响应数据报的组装并返还给前端。

![image-20221122161525111](.\assets\image-20221122161525111.png)

#### 算法和流程

该模块不涉及特定算法。

#### 数据设计

数据通信模块主要用到两个数据结构。

##### relation 表示关系的数据结构（表）

包含五个字段：关系名、行长、列长、列名以及表的内容。

表的内容（content）使用一个字符串表示，每个元素间使用英文逗号分隔，应当满足字符串内元素的数量等于行长乘以列长。

举例，以下关系以及对应的Json结构：

| name   | age | gender |
| ------ | --- | ------ |
| Johnny | 18  | male   |
| Jack   | 20  | male   |

```json
{
    "relation_name":"student",
    "row_len":3,
    "col_len":2,
    "col_name":"name,age,gender",
    "content":"Johnny,18,male,Jack,20,male"
}
```

##### response 响应

前端调用接口后返回的是一个response对象，包含三个字段：状态码、信息、数据体。如果是需要返回结果的请求调用，结果对象会存储在数据体中。

举例，一个请求成功，且返回数据存放在data中的response对象：

```json
{
    "code":200,
    "msg":"ok",
    "data":{
        "relation_name":"student",
        "row_len":3,
        "col_len":2,
        "col_name":"name,age,gender",
        "content":"Johnny,18,male,Jack,20,male"
    }
}
```

#### 源程序文件说明

##### 前端部分

该模块主要完成前端向后端提交、删除、重置表单以及提交表达式函数。

```javascript
// InputTable.vue 向后端传表单
    submit (item) {
      this.$axios
        .post('/insert/', {...})
        .then(successResponse => {
          if (successResponse.data.code === 200) {...}
          else if (successResponse.data.code === 400) {...}})
        .catch(failResponse => {...})
    }
// InputTable.vue 删除表单项
    removeDomain (item) {
      ...
      this.$axios
        .post('/delete/', {...})
        .then(successResponse => {
          if (successResponse.data.code === 200) {...}})
        .catch(failResponse => {...})
    }
// InputTable.vue 重置
    reset () {
      this.$axios
        .get('/delete_all/', {})
        .then(successResponse => {
          if (successResponse.data.code === 200) {...}
          this.reload() // 调用刷新
        })
        .catch(failResponse => {...})
    }
// InputExpression.vue 提交表达式
    submit () {
      ...
      this.$axios
        .post('/compute/', {...})
        .then(successResponse => {
          if (successResponse.data.code === 200) {...} 
          else if (successResponse.data.code === 400) {...}
        })
    }
```

##### 后端部分

该模块后端由`WebController`类构成，负责向前端提供各种功能的http接口。篇幅原因，以下源程序省略了详细实现，仅保留主要的接口方法。

```java
public class WebController {

    /**
     * 计算表达式结果并返回
     * @return
     */
    @RequestMapping(value = "/api/compute/", method = RequestMethod.POST)
    public Result getCalculationResult(@RequestBody String expression);

    /**
     * 新建关系
     * @return
     */
    @RequestMapping(value = "/api/insert/", method = RequestMethod.POST)
    public Result insertRelation(@RequestBody RelationVo vo);

    /**
     * 删除关系
     * @return
     */
    @RequestMapping(value = "/api/delete/", method = RequestMethod.POST)
    public Result deleteRelation(@RequestBody String name);

    /**
     * 删除所有关系
     * @return
     */
    @RequestMapping(value = "/api/delete_all/", method = RequestMethod.GET)
    public Result deleteAll();
}
```

#### 主要函数说明

##### 前端部分

关系管理部分中主要提供了3个接口方法：

- `submit`：POST方法，向后端传表单，入参为关系表的表名，行数，列数，列名，及表单具体内容，出参为http响应报文。

- `removeDomain`：POST方法，删除后端表单项，入参为关系表的表名，出参为http响应报文。

- `reset`：GET方法，重置后端所有表单项，入参为空，出差为http响应报文。

表达式输入部分中主要提供了1个接口方法：

- `submit`：POST方法，像后端传关系表达式，获取表达式，并将关系符转换为相应的#形式，入参为表达式，出参为json形式存储在数据体的http响应报文。

##### 后端部分

`WebController`主要提供了4个接口方法。

- `getCalculationResult`：POST方法，获取计算结果，入参为字符串形式的计算表达式，出参为结果以json形式存储在数据体的http响应报文。
- `insertRelation`：POST方法，新增关系，入参为json格式的关系数据结构，出参为http响应报文，根据插入的结果是否成功来决定其状态码以及附注信息。
- `deteleRelation`：POST方法，删除关系，入参为字符串格式的关系名，出参同上，根据删除结果是否成功来回复成功/失败的响应报文。
- `deteleAll`：GET方法，删除所有关系（重置），不需要入参，调用该方法时删除所有已有的关系，根据删除结果是否成功来回复成功/失败的响应报文。

### 2.3 关系业务模块

#### 功能描述

处理关系的增/删/取，与持久化模块直接交互，涉及到关系的一系列操作都需要经过此模块。

#### 输入数据

可以分为三个输入源，一个是数据通信模块，输入为用户执行的操作以及关系信息，根据用户的操作，该模块执行对应的功能；另一个是关系计算模块，输入为关系名，根据关系名获取详细的关系信息；最后是持久化模块，根据关系名获取关系详细数据。

这一层会对关系的数据合法性进行全面校验，包括关系的内容是否符合关系的行列长等。

#### 输出数据

针对三个输入源，分别有对应的输出。对于数据通信模块，输出为关系增删是否成功的结果；针对关系计算模块，输出为名称对应的关系数据结构；持久化模块则在用户新增/删除或是计算模块获取关系详细数据时由业务模块代为处理，向持久化模块输出对应参数进行处理。

![image-20221122164607178](.\assets\image-20221122164607178.png)

#### 算法和流程

该模块不涉及特定算法。

#### 数据设计

存储关系主要涉及两个类，`RelationVo`以及`RelationBo`，前者主要用于与前端交互时存储从前端送来的关系/准备送至前端的关系信息，后者则主要用于后端业务处理，包括关系的存储/表达式的运算等。

鉴于二者相似性，仅详细介绍`RelationBo`的成员，伪代码如下。

```java
RelationBo {

    // 关系行长
    int rowLen;

    // 关系列长
    int colLen;

    // 关系列名
    String[] colName;

    // 关系内容，通过二维数组存储
    String[][] content;

    // bo与vo相互转换的方法
    toRelationVo(RelationBo bo, String name);

    toRelationBo(RelationVo vo, String name);
}
```

#### 源程序文件说明

`RelationService`接口为关系业务模块的主要体现，以下展示其接口源码，展示了其有哪些对外方法。具体的实现类请查看源码中的`RelationServiceImpl`。

```java
public interface RelationService {

    /**
     * @param relationVo 前端传来的Relations
     * @throws ParamLenException 参数不对时抛出此异常
     */
    void insertRelation(RelationVo relationVo) throws ParamLenException;

    /**
     * 删除关系
     */
    void deleteRelation(String name);

    /**
     * 删除所有已建立关系
     */
    void deleteAll();

    /**
     * 是否存在名为key的关系
     * @param key
     * @return
     */
    boolean contains(String key);

    /**
     * 获取name对应的Bo
     * @param name
     * @return
     */
    RelationBo get(String name);
}
```

#### 主要函数说明

`RelationService`提供了下列对外的方法。

- `insertRelation`：新增关系，入参为vo形式的关系数据，无出参，添加成功时不返回参数，添加失败时会抛出参数错误异常。
- `deleteRelation`：删除特定关系，入参为字符串形式的关系名，无出参。
- `deleteAll`：删除所有关系，重置，入参与出参皆为空。
- `contains`：是否包含对应名字的关系，入参为字符串形式的关系名，出参为布尔值。
- `get`：获取对应名称的关系信息，入参为字符串形式的关系名，出参为对应关系的数据结构，未找到时为null。

### 2.4 持久化模块

#### 功能描述

负责存储用户定义的关系，以及通过关系业务模块向计算模块提供关系信息。

#### 输入数据

只与关系业务模块直接交互，输入为关系信息/用户操作等。

#### 输出数据

只与关系业务模块直接交互，输出为关系的详细信息。

#### 算法和流程

不涉及特定算法，关系存储使用`java.util.Map.CurrentHashMap`类。

#### 数据设计

参见关系业务模块。为`RelationBo`。

#### 源程序文件说明

参见关系业务模块。

#### 主要函数说明

参见业务关系模块。

### 2.5 代数运算模块

#### 功能描述

通过关系业务模块以及各种工具类的辅助，完成数据通信模块传来的表达式的计算求值，并向数据通信模块返回求得的结果。

#### 输入数据

由数据通信模块输入待计算的表达式，由关系业务模块输入需要用到的关系数据，共同完成表达式的结果计算。

#### 输出数据

计算结果完成后，结果也是一个关系，将该关系输出传递给数据传输模块进行包装返回前端。

![image-20221122204653628](.\assets\image-20221122204653628.png)

#### 算法和流程

目前的算法仅针对二元关系运算符，一元运算符由于参数较多、逻辑较复杂，还有待讨论。

##### 提取表达式的每一项元素

对于每个关系运算表达式，规定**关系名、括号、运算符**之间通过英文空格分离，以便简易地将表达式从一个字符串类型转化为一个字符串数组类型，可以将该数组在下文称为`list`。该数组每一项都为一个关系名、括号或是运算符。

##### 关系表达式转逆波兰表达式

为将关系表达式转为易于计算机处理的类型，需要将原来的中缀类型的表达式转为逆波兰表达式。而这种转换需要通过使用**栈**来辅助完成。以下简述该算法步骤，`res`来表示转换后的结果数组，算法的流程图如下：

![](.\assets\中缀转后缀流程图.png)

文字表述如下：

1. 由左到右开始，逐项扫描关系表达式数组`list`。
2. 遇到关系名，直接添加到结果数组`res`。
3. 遇到关系运算符或是括号，根据以下几种情况来处理。
   1. 若为左括号`(`，则将左括号入栈；
   2. 若为右括号`)`，则将栈中的元素依次出栈并添加到`res`，直到遇到`(`，`(`仅出栈且不添加到`res`。
   3. 若为其他关系运算符，将栈中的元素依次出栈并添加到`res`，直到遇到比当前运算符优先级更低的运算符或者`(`，然后将当前运算符入栈。
4. 扫描完成后，将栈中剩余的运算符依次弹出，添加至`res`。

##### 计算逆波兰表达式

将关系代数表达式转化为逆波兰表达式后，可以继续进行结果的计算了。同样，需要用到栈这一数据结构的辅助。

![](.\assets\计算后缀表达式流程图.png)

文字表述如下：

1. 由左到右开始，逐项扫描逆波兰表达式数组`res`。
2. 遇到关系名则压栈。
3. 遇到关系运算符，则弹出栈顶的两个元素，先弹出的在右边，后弹出的在左边，进行计算，将结果关系压栈。
4. 扫描完成后，弹出栈顶元素，即为最终结果。

以上步骤即为计算关系表达式的步骤。

#### 数据设计

用到的数据结构为`RelationBo`，具体见关系业务模块；同时计算过程中使用到栈这一辅助数据结构。

#### 源程序文件说明

接口`ComputingService`的实现类`ComputingServiceImpl`为该模块主要的类，包含上述两个算法。

**计算逆波兰表达式**

```java
    /**
     * 计算后缀表达式
     * @param expression
     * @return
     */
    private RelationBo calculate(String expression) throws ComputingException {
        List<String> post = parse(expression);
        Deque<RelationBo> stack = new ArrayDeque<>();
        for (String elem : post) {
           if (relationService.contains(elem)) {
               stack.push(relationService.get(elem));
               continue;
           }
           String operation = elem;
           RelationBo bo1 = stack.poll(), bo2 = stack.poll();
           RelationBo res = null;
           switch (operation) {
               case Constant.AND:
                   res = ComputingUtil.and(bo1, bo2);
                   break;
               case Constant.OR:
                   res = ComputingUtil.or(bo1, bo2);
                   break;
               case Constant.PROD:
                   res = ComputingUtil.prod(bo1, bo2);
                   break;
               case Constant.DIFF:
                   res = ComputingUtil.diff(bo1, bo2);
                   break;
               default:
                   throw new ComputingException();
           }
           stack.push(res);
        }
        return null;
    }
```

**中缀转逆波兰表达式**

```java
    /**
     * 中缀转后缀
     * @param expression
     * @return
     */
    private List<String> parse(String expression) {
        String[] elems = expression.split(" ");
        List<String> res = new ArrayList<>();
        Deque<String> stack = new ArrayDeque<>();
        for (String elem : elems) {
            if (relationService.contains(elem)) {
                res.add(elem);
                continue;
            }
            if (elem.equals("(") || (elem.charAt(0) == '#') && stack.isEmpty()) {
                stack.push(elem);
                continue;
            }
            if (elem.equals(")")) {
                while (!stack.isEmpty() && !stack.peek().equals("(")) {
                    res.add(stack.poll());
                }
                stack.poll();
                continue;
            }
            while (!stack.isEmpty()
                    && !stack.peek().equals("(")
                    && Constant.PRIORITY.get(elem) >= Constant.PRIORITY.get(stack.peek())) {
                res.add(stack.poll());
            }
            stack.push(elem);
        }
        while (!stack.isEmpty()) {
            res.add(stack.poll());
        }
        return res;
    }
```

运算工具类则负责各种运算符运算的具体实现，定义的接口如下，实现因篇幅原因请见代码附件。运算工具类`ComputingUtil`用于计算关系运算符的结果。其包含了8个对外暴露的方法，分别对应着不同的8种运算符。

```java
public class ComputingUtil {

    public static RelationBo and(RelationBo r1, RelationBo r2);

    public static RelationBo or(RelationBo r1, RelationBo r2);

    public static RelationBo diff(RelationBo r1, RelationBo r2);

    public static RelationBo prod(RelationBo r1, RelationBo r2);

    public static RelationBo div(RelationBo r1, RelationBo r2);

    public static RelationBo select(RelationBo r, String condition);

    public static RelationBo project(RelationBo r, int[] cols);

    public static RelationBo join(RelationBo r1, RelationBo r2);
}
```

#### 主要函数说明

- `parse`：将关系表达式转化为逆波兰表达式的形式，入参为字符串形式的表达式，出参为一个字符串数组，每一项都为逆波兰表达式中的一项。
- `calculate`：计算，将逆波兰表达式计算除最后的结果，入参为字符串数组，出参为一个关系实例（`RelationBo`类的实例）。

## 三、模块间接口详细设计

### 3.1 后端模块内部接口

后端程序中主要涉及到两个主要接口。`ComputingService`用于表达式的计算，对外提供了以表达式字符串为入参计算表达式的接口。`RelationService`用于关系业务的处理，对外暴露的接口可以执行关系的新增、删除、重置等操作。

`RelationService`接口定义（关系业务模块）

```Java
/**
 * @program: operation_system
 * @description: 管理（新建/删除）Relation接口
 * @author: Xuan
 * @create: 2022-10-18 20:39
 **/
public interface RelationService {

    /**
     * @param relationVo 前端传来的Relations
     * @throws ParamLenException 参数不对时抛出此异常
     */
    void insertRelation(RelationVo relationVo) throws ParamLenException;

    /**
     * 删除关系
     */
    void deleteRelation(String name);

    /**
     * 删除所有已建立关系
     */
    void deleteAll();

    /**
     * 是否存在名为key的关系
     * @param key
     * @return
     */
    boolean contains(String key);

    /**
     * 获取name对应的Bo
     * @param name
     * @return
     */
    RelationBo get(String name);
}
```

需要调用时，在调用类内部通过bean注入接口实例至成员变量中，调用实例对应的方法传入正确的参数以使用。

`ComputingService`接口定义（表达式计算模块）

```java
/**
 * @program: operation_system
 * @description: 计算表达式接口
 * @author: Xuan
 * @create: 2022-10-17 15:12
 **/
public interface ComputingService {

    /**
     * @param expression 关系代数表达式
     * @return 计算后的结果
     */
    RelationVo compute(String expression) throws ComputingException;

}
```

同样，在需要调用时，在调用类内部通过bean注入接口实例至成员变量中，调用实例对应的方法传入正确的参数以使用。

### 3.2 前后端模块间接口

前后端接口交互采用http的形式，需要访问接口时通过访问对应的URL并使用约定的http方法来访问。如需要新增关系时，前端访问的接口地址为`{后端ip地址}:8081/api/insert/`，使用POST方法，将关系数据以Json格式放入数据体中。

#### 新增关系

- 调用方式：POST
- URL：`/api/insert/`
- 入参：relation
- 出参：data为空的response
- 说明：新增关系，保存至后端。支持传入一个Json格式的关系。

例子如下。

**入参**

```json
{
    "relation_name":"student",
    "row_len":3,
    "col_len":2,
    "col_name":"name,age,gender",
    "content":"Johnny,18,male,Jack,20,male"
}
```

**出参**

```json
{
    "code":200,
    "msg":"ok",
    "data":{}
}
```

#### 删除关系

- 调用方式：POST
- URL：`/api/delete/`
- 入参：关系名
- 出参：data为空的response
- 说明：删除关系。

例子如下。

**入参**

```json
{
    "name":"student"
}
```

**出参**

```json
{
    "code":200,
    "msg":"ok",
    "data":{}
}
```

#### 重置

- 调用方式：GET
- URL：`/api/delete_all/`
- 入参：无
- 出参：data为空的response
- 说明：删除已有的所有关系。

例子如下。

**出参**

```json
{
    "code":200,
    "msg":"ok",
    "data":{}
}
```

#### 计算关系代数

- 调用方式：POST
- URL：`/api/compute/`
- 入参：表达式字符串
- 出参：data为计算结果（一个relation）的response
- 说明：计算关系代数表达式，内部出现的关系必须事先定义过。

关系运算符在表达式字符串中的表示对应关系如下。

| 运算符 | 含义   | 字符串中的表示  | 举例                         | 说明  |
| --- | ---- | -------- | -------------------------- | --- |
| ∪   | 并    | #or      | A #or B                    |     |
| ∩   | 交    | #and     | A #and B                   |     |
| −   | 差    | #diff    | A #diff B                  |     |
| ×   | 笛卡尔积 | #prod    | A #prod B                  |     |
| σ   | 选择   | #select  | #select(A,name=\\"Jack\\") |     |
| π   | 投影   | #project | #project(A,name)           |     |
| ⋈   | 连接   | #join    | #join(A,B,0~3)             |     |
| ÷   | 除    | #div     | A #div B                   |     |

共计8个运算类型，并、交、差、笛卡尔积、选择、投影、连接、除。

**优先级定义：括号 > 三种特殊运算符 > 差 > 积 = 除 > 交 > 并**

例子如下。

**入参**

> 注意：任意两个符号（运算符、关系名或是括号）之间请添加一个英文空格。

```json
{
    "expression":"( student #or class ) #and teacher"
}
```

**出参**

```json
{
    "code":200,
    "msg":"ok",
    "data":{
        "relation_name":"student",
        "row_len":3,
        "col_len":2,
        "col_name":"name,age,gender",
        "content":"Johnny,18,male,Jack,20,male"
    }
}
```
