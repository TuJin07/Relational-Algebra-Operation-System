# PPT文案

## 需求分析

## 解决方案

### 软件整体结构

#### 以Web网页为入口的前后端系统设计

整个系统可以分为前端以及后端两个大的模块，后端是使用Java编写的，前端是通过Vue.js编写的，Web浏览器作为整个程序的入口，程序拥有完整的交互界面，用户通过在网页上点击交互界面来使用系统的各种功能。

<img src=".\assets\软件总体结构和功能模块设计.drawio.png" alt="image-20221105235026964" style="zoom: 80%;" />

![image-20230110212626835](assets\image-20230110212626835.png)

#### 各功能模块介绍

如图所示，为了实际开发的遍历以及后期的可维护性，我们将整个系统分割为若干模块。各个模块各司其职，通过数据通信共同完成功能。

<img src=".\assets\模块之间的层次结构以及模块间的调用关系.drawio.png" alt="image-20221105235133897" style="zoom:50%;" />

### 关键问题

- 如何判断用户的输入表达式是否合法？
- 如何计算关系代数表达式？

### 解决关键问题的算法

#### 词法分析与语法分析解决输入合法性问题

##### 词法分析

###### DFA推导过程

通过词法分析，我们可以判断输入的计算表达式中是否含非法的字符。这一步骤由程序实现，则需要首先推导出我们的DFA（`deterministic finite automaton`有限状态自动机）。

使用正规式定义标识符记号id，数字记号num，运算符记号operator:

$id = char(char|digit)^*$

$num = digits optional\_fraction$

$operator = ∩|∪|−|×|⋈|÷|π|σ|∧|∨|(|)|[|]|.|≤|≥|≠|>|<|=|,$

其中辅助定义式：

$char = [a-zA-Z]$

$digit = [0-9]$

$digits = digit^+$

$optional_fraction = (.digits)?$

通过正规式构建DFA如下图所示。

![image-20230110175521865](D:\Relational-Algebra-Operation-System\doc\assets\image-20230110175521865.png)

有了DFA，我们就可以基于DFA的基础来编写词法分析程序，进而解决了输入表达式中包含不合法的字符的问题。

##### 语法分析

###### 预测分析表推导过程

除此之外，还需要考虑的是用户输入的表达式的语法是否正确，这一步我们使用了语法分析来进行校验。要让程序能具备语法分析的能力，需要先获得关系表达式的分析预测表。以下就是我们的推导过程。

1. 用产生式表示文法，其中A：表达式，id：标识符，num：数字

   ```
   A -> A∩B | B
   B -> B∪C | C
   C -> C×D | C÷D | D
   D -> D−E | E
   E -> E⋈F | F
   F -> π[G][A] | σ[I][A] | (A) | id
   G -> idH
   H -> ,idH | Ɛ
   I -> I∧J | J
   J -> J∨K | K
   K -> (I) | idL
   L -> =M | >M | ≥M | <M | ≤M | ≠M
   M -> id | num
   ```

2. 消除左递归和公共左因子

   ```
   A -> CB
   B -> ∩CB | Ɛ
   C -> ED
   D -> ∪ED | Ɛ
   E -> GF
   F -> ×GF | ÷GF | Ɛ
   G -> IH
   H -> −IH | Ɛ
   I -> KJ
   J -> ⋈KJ | Ɛ
   K -> π[L][A] | σ[N][A] | (A) | id
   L -> idM
   M -> ,idM | Ɛ
   N -> PO
   O -> ∧PO | Ɛ
   P -> RQ
   Q -> ∨RQ | Ɛ
   R -> (N) | idS
   S -> =T | >T | ≥T | <T | ≤T | ≠T
   T -> id | num
   ```

3. 求解First集和Follow集

   <img src="D:\Relational-Algebra-Operation-System\doc\assets\image-20230110175403945.png" alt="image-20230110175403945" style="zoom:67%;" />

###### 预测分析表

得到最终的预测分析表如下。

![image-20230110191018927](assets\image-20230110191018927.png)

###### 语法分析的程序实现步骤

通过预测分析表以及辅助栈的帮助，可以使程序按如下步骤完成语法分析的过程。先入栈终止符，再入栈起始符。循环执行以下步骤之一。

1. 栈顶符号X = 输入符号a = 终止符，则分析成功，停止分析。
2. 栈顶符号X = 输入符号a 不等于 终止符，将X从栈顶出栈，a指向下一个输入符号。
3. 栈顶符号X是非终结符，查分析表table。
   - 若table[X, a]中存放着关于X的一个产生式，将X出栈，将产生式右部符号串按反序一一入栈。若符号为空，则不如栈。
   - 若table[X, a]中存放着出错标志ERROR，则判断表达式不合法。

通过以上步骤即可对输入字符串完成语法分析。

#### 逆波兰表达式转换与计算

过前置的合法性分析以及前后端约定的传输格式，现在已经可以得到一个格式合法的、运算符与标识符等元素被分隔的以字符串数组形式表示的关系代数表达式。接下来另一个关键问题，即表达式如何计算得到结果，我们参考了计算机处理四则运算的思路。

##### 逆波兰表达式转换

逆波兰表达式中，所有操作符置于操作数的后面，因此也被称为后缀表达式、后序表达式。逆波兰记法不需要括号来标识操作符的优先级。因为逆波兰表达式的处理更符合计算的处理逻辑，所以先通过程序将输入的中缀表达式转换为逆波兰表达式以便后续的计算处理。

![](.\assets\中缀转后缀流程图.png)

算法的文字表述如下，需要用到栈的辅助：

1. 由左到右开始，逐项扫描关系表达式数组`list`。
2. 遇到单目运算符，将单目运算符内的表达式进行递归计算处理，得到结果后计算单目运算符，将最后的结果加入res。
3. 遇到关系名，直接添加到结果数组`res`。
4. 遇到关系运算符或是括号，根据以下几种情况来处理。
   1. 若为左括号`(`，则将左括号入栈；
   2. 若为右括号`)`，则将栈中的元素依次出栈并添加到`res`，直到遇到`(`，`(`仅出栈且不添加到`res`。
   3. 若为其他关系运算符，将栈中的元素依次出栈并添加到`res`，直到遇到比当前运算符优先级更低的运算符或者`(`，然后将当前运算符入栈。
5. 扫描完成后，将栈中剩余的运算符依次弹出，添加至`res`。

最后得到的`res`即为逆波兰表达式结果。

##### 计算逆波兰表达式

![](.\assets\计算后缀表达式流程图.png)

文字表述如下：

1. 由左到右开始，逐项扫描逆波兰表达式数组`res`。
2. 遇到关系名则压栈。
3. 遇到关系运算符，则弹出栈顶的两个元素，先弹出的在右边，后弹出的在左边，进行计算，将结果关系压栈。
4. 扫描完成后，弹出栈顶元素，即为最终结果。

以上步骤即为计算关系表达式的步骤。

#### 单目运算符的递归预处理

上述借助处理四则运算的思路衍生出的逆波兰表达式计算法其实对于处理关系运算有个问题，就是关系代数运算中存在着选择以及投影两个单目运算符。而上面的算法实际上处理不了单目运算符的，回一下四则运算中的单目运算符也就是负号，在计算过程中实在中缀表达式转逆波兰表达式这一步就将其与数字合并成一个整体供后续计算。

借助这个思路，我们引入了对单目表达式的预处理来改进上述的算法，使其支持单目表达式的计算。

如整体流程图所示，在中缀表达式转逆波兰表达式中，当我们遇到单目运算符时，我们就对其进行预处理，即提前计算出该运算符的结果，用作为结果的表来替换掉整个单目运算符，继续参与后续的计算，这样，在核心算法不需要大改的情况下，通过在转逆波兰表达式这一过程中的预处理完美解决了单目运算符的问题。

![image-20230110215337651](assets\框选.png)

## 结果展示

直接跳到网页上演示吧，提前准备好几个用例，包含各方面的。